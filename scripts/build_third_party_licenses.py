#!/usr/bin/env python3

# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2025 Addison Kline

from __future__ import annotations

import argparse
import logging
import sys
import textwrap
from collections.abc import Iterable
from dataclasses import dataclass, field
from pathlib import Path

try:  # Python 3.11+
    import tomllib  # type: ignore[attr-defined]
except ModuleNotFoundError:  # pragma: no cover
    import tomli as tomllib  # type: ignore[assignment]

from importlib import metadata

DEFAULT_LOCK_PATH = Path("uv.lock")
DEFAULT_OUTPUT_PATH = Path("THIRD_PARTY_NOTICES.md")


@dataclass
class PackageReport:
    """
    A container of metadata about a third-party package.
    Ideally contains all relevant license information.
    """
    name: str
    version: str
    summary: str | None = None
    license: str | None = None
    license_classifiers: list[str] = field(default_factory=list)
    home_page: str | None = None
    author: str | None = None
    license_texts: list[tuple[str, str]] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)


def load_packages(lock_path: Path) -> dict[str, str]:
    """
    Load the packages from the `uv.lock` file.
    """
    data = tomllib.loads(lock_path.read_text(encoding="utf-8"))
    packages = {}

    for entry in data.get("package", []):
        name = entry.get("name")
        version = entry.get("version")
        if not name or not version:
            continue
        packages[name] = version

    return packages


def pick_license_texts(dist: metadata.Distribution) -> list[str]:
    """
    Pick the license texts from the distribution.
    """
    meta = dist.metadata
    declared = meta.get_all("License-File")
    if declared is not None:
        return [str(item) for item in declared]

    # Fallback: scan files for LICENSE-like names.
    candidates: list[str] = []
    for file in dist.files or []:
        normalized = str(file).lower()
        if any(marker in normalized for marker in ("license", "copying")):
            candidates.append(str(file))

    return sorted(dict.fromkeys(candidates))


def read_license_file(dist: metadata.Distribution, relative_path: str) -> str | None:
    """
    Attempt to read the license file from a distribution and return its contents.
    """
    try:
        content = dist.read_text(relative_path)
        if content is not None:
            return content
    except FileNotFoundError:
        pass

    try:
        file_path = dist.locate_file(relative_path)
    except FileNotFoundError:
        return None
    
    path_obj = Path(file_path)
    if not path_obj.exists():
        return None

    return path_obj.read_text(encoding="utf-8", errors="replace")


def build_report(name: str, version: str) -> PackageReport:
    """
    Build a `PackageReport` for a third-party package given its name and version.
    """
    report = PackageReport(name=name, version=version)

    try:
        dist = metadata.distribution(name)
    except metadata.PackageNotFoundError:
        report.warnings.append("Package not installed; install to capture metadata.")
        return report

    meta = dist.metadata
    report.summary = meta.get("Summary")
    report.license = meta.get("License-Expression")
    report.license_classifiers = meta.get_all("Classifier") or []
    report.home_page = meta.get("Home-page")
    report.author = meta.get("Author")

    for rel_path in pick_license_texts(dist):
        text = read_license_file(dist, rel_path)
        if text:
            report.license_texts.append((rel_path, text))
        else:
            report.warnings.append(f"Unable to read license file: {rel_path}")

    if not report.license and not report.license_texts:
        report.warnings.append("No license metadata discovered; manual review needed.")
        print(f"report for {dist.name}:\n{[key for key in dist.metadata.keys()]}")
    
    return report


def format_classifier_summary(classifiers: Iterable[str]) -> list[str]:
    """
    Format license classifiers into a summary list.
    """
    results = []

    for classifier in classifiers:
        if classifier.startswith("License ::"):
            results.append(classifier)

    return results


def write_output(reports: Iterable[PackageReport], output_path: Path) -> None:
    """
    Write the reports to a file.
    """
    header = textwrap.dedent(
        """
        # Third-Party Notices

        _Generated by [scripts/build_third_party_licenses.py](/scripts/build_third_party_licenses.py). 
        Ensure all listed packages remain installed when re-running 
        so their license metadata stays accessible._
        """
    ).strip()

    lines: list[str] = [header, ""]

    for report in sorted(reports, key=lambda r: r.name.lower()):
        title = f"## `{report.name}=={report.version}`"
        lines.append(title)

        if report.summary:
            lines.append(f"{report.summary}")
        license_line = report.license or "(license metadata not found)"
        lines.append(f"- License field: {license_line}")

        classifiers = format_classifier_summary(report.license_classifiers)
        if classifiers:
            lines.append("- Classifiers: " + "; ".join(classifiers))
        if report.home_page:
            lines.append(f"- Home page: {report.home_page}")
        if report.author:
            lines.append(f"- Author: {report.author}")
        if report.warnings:
            for warning in report.warnings:
                lines.append(f"- Warning: {warning}")

        if report.license_texts:
            for rel_path, text in report.license_texts:
                lines.append("")
                lines.append(f"### License Text ({rel_path})")
                lines.append("")
                lines.append("```text")
                lines.append(text.strip())
                lines.append("```")

        lines.append("")

    output_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def parse_args(argv: list[str]) -> argparse.Namespace:
    """
    Parse the command line arguments using `argparse`.
    """
    parser = argparse.ArgumentParser(description="Build a third-party license report.")
    parser.add_argument(
        "--lock-file",
        type=Path,
        default=DEFAULT_LOCK_PATH,
        help="Path to the uv.lock file",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT_PATH,
        help="Destination file for the generated report",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable debug logging",
    )
    return parser.parse_args(argv)


def main(argv: list[str] | None = None) -> int:
    args = parse_args(argv or sys.argv[1:])

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    if not args.lock_file.exists():
        logging.error("Lock file not found: %s", args.lock_file)
        return 1

    packages = load_packages(args.lock_file)
    if not packages:
        logging.error("No packages found in %s", args.lock_file)
        return 1

    reports: list[PackageReport] = []
    for name, version in packages.items():
        report = build_report(name, version)
        reports.append(report)
        if args.verbose and report.warnings:
            for warning in report.warnings:
                logging.warning("%s: %s", name, warning)

    write_output(reports, args.output)
    logging.info("Wrote license report for %d packages to %s", len(reports), args.output)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
